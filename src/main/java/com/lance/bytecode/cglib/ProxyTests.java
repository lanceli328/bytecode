package com.lance.bytecode.cglib;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertTrue;

import com.lance.bytecode.BankTransactions;
import java.lang.reflect.Method;
import net.sf.cglib.beans.BeanCopier;
import net.sf.cglib.beans.BeanGenerator;
import net.sf.cglib.beans.BeanMap;
import net.sf.cglib.beans.BulkBean;
import net.sf.cglib.beans.ImmutableBean;
import net.sf.cglib.core.DebuggingClassWriter;
import net.sf.cglib.proxy.CallbackHelper;
import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.FixedValue;
import net.sf.cglib.proxy.InvocationHandler;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;
import net.sf.cglib.proxy.NoOp;
import net.sf.cglib.reflect.FastClass;
import net.sf.cglib.reflect.FastMethod;
import net.sf.cglib.util.ParallelSorter;
import org.junit.Before;
import org.junit.Test;

/**
 * Created by lihua on 18/4/2017.
 * email: lihua@seczone.cn
 */
public class ProxyTests {

  @Before
  public void beforeTest() {
    System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, "cglib");
  }

  /**
   * In the below example, the enhancer will return an instance of an instrumented subclass of
   * SampleClass where all method calls return a fixed value which is generated by the anonymous
   * FixedValue implementation above.
   *
   * Be aware that any method call will be delegated in the above example, also calls to the methods
   * defined in java.lang.Object. As a result, a call to proxy.toString() will also return "Hello
   * cglib!".
   */
  @Test
  public void testFixedValue() throws Exception {
    Enhancer enhancer = new Enhancer();
    enhancer.setSuperclass(BankTransactions.class);
    enhancer.setCallback(new FixedValue() {
      @Override
      public Object loadObject() throws Exception {
        System.out.println("Hello cglib!");
        return "Hello cglib!";
      }
    });
    BankTransactions proxy = (BankTransactions) enhancer.create();
    assertEquals("Hello cglib!", proxy.withdraw("lance", 100.0));
    assertEquals("Hello cglib!", proxy.login("test", "lance", "lance"));
  }

  /**
   * All call will be proxy by InvocationHandler expect call from Object
   */
  @Test
  public void testInvocationHandler() throws Exception {
    Enhancer enhancer = new Enhancer();
    enhancer.setSuperclass(BankTransactions.class);
    enhancer.setCallback(new InvocationHandler() {
      @Override
      public Object invoke(Object proxy, Method method, Object[] args)
          throws Throwable {
        if (method.getDeclaringClass() != Object.class && method.getReturnType() == String.class) {
          System.out.println("Hello cglib!");
          return "Hello cglib!";
        } else {
          throw new RuntimeException("Do not know what to do.");
        }
      }
    });
    BankTransactions proxy = (BankTransactions) enhancer.create();
    assertEquals("Hello cglib!", proxy.withdraw("lance", 1.0));
    assertNotEquals("Hello cglib!", proxy.toString());
  }

  @Test
  public void testMethodInterceptor() throws Exception {
    Enhancer enhancer = new Enhancer();
    enhancer.setSuperclass(BankTransactions.class);
    enhancer.setCallback(new MethodInterceptor() {
      @Override
      public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy)
          throws Throwable {
        if (method.getDeclaringClass() != Object.class && method.getReturnType() == String.class) {
          return "Hello cglib!";
        } else {
          Object result = proxy.invokeSuper(obj, args);
          return result;
        }
      }
    });
    BankTransactions proxy = (BankTransactions) enhancer.create();
    assertEquals("Hello cglib!", proxy.withdraw("lance", 2.0));
    assertNotEquals("Hello cglib!", proxy.toString());
    proxy.hashCode(); // Does not throw an exception or result in an endless loop.
  }

  @Test
  public void testCallbackFilter() throws Exception {
    Enhancer enhancer = new Enhancer();
    CallbackHelper callbackHelper = new CallbackHelper(BankTransactions.class, new Class[0]) {
      @Override
      protected Object getCallback(Method method) {
        if (method.getDeclaringClass() != Object.class && method.getReturnType() == String.class) {
          return new FixedValue() {
            @Override
            public Object loadObject() throws Exception {
              return "Hello cglib!";
            }
          };
        } else {
          return NoOp.INSTANCE; // A singleton provided by NoOp.
        }
      }
    };
    enhancer.setSuperclass(BankTransactions.class);
    enhancer.setCallbackFilter(callbackHelper);
    enhancer.setCallbacks(callbackHelper.getCallbacks());
    BankTransactions proxy = (BankTransactions) enhancer.create();
    assertEquals("Hello cglib!", proxy.withdraw("lance", 1.0));
    assertNotEquals("Hello cglib!", proxy.toString());
    proxy.hashCode(); // Does not throw an exception or result in an endless loop.
  }

  /**
   * The ParallelSorter claims to be a faster alternative to the Java standard library's array
   * sorters when sorting arrays of arrays
   */
  @Test
  public void testParallelSorter() throws Exception {
    Integer[][] value = {
        {4, 3, 9, 0},
        {2, 1, 6, 0}
    };
    ParallelSorter.create(value).mergeSort(0);
    for (Integer[] row : value) {
      int former = -1;
      for (int val : row) {
        assertTrue(former < val);
        former = val;
      }
    }
  }

  /**
   * The FastClass promises a faster invocation of methods than the Java reflection API by wrapping
   * a Java class and offering similar methods to the reflection API
   *
   * Besides the demonstrated FastMethod, the FastClass can also create FastConstructors but no fast
   * fields. But how can the FastClass be faster than normal reflection? Java reflection is executed
   * by JNI where method invocations are executed by some C-code. The FastClass on the other side
   * creates some byte code that calls the method directly from within the JVM. However, the newer
   * versions of the HotSpot JVM (and probably many other modern JVMs) know a concept called
   * inflation where the JVM will translate reflective method calls into native version's of
   * FastClass when a reflective method is executed often enough. You can even control this behavior
   * (at least on a HotSpot JVM) with setting the sun.reflect.inflationThreshold property to a lower
   * value. (The default is 15.) This property determines after how many reflective invocations a
   * JNI call should be substituted by a byte code instrumented version. I would therefore recommend
   * to not use FastClass on modern JVMs, it can however fine-tune performance on older Java virtual
   * machines.
   */
  @Test
  public void testFastClass() throws Exception {
    FastClass fastClass = FastClass.create(SampleBean.class);
    FastMethod fastMethod = fastClass.getMethod(SampleBean.class.getMethod("getValue"));
    SampleBean myBean = new SampleBean();
    myBean.setValue("Hello cglib!");
    assertEquals("Hello cglib!", fastMethod.invoke(myBean, new Object[0]));
  }

}
